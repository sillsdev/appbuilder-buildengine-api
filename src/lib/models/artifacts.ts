import type { Prisma } from '@prisma/client';
import { Build } from './build';
import { Release } from './release';

const ARTIFACT_AAB = 'aab';
const ARTIFACT_APK = 'apk';
const ARTIFACT_VERSION_CODE = 'version_code';
const ARTIFACT_VERSION = 'version';
const ARTIFACT_ABOUT = 'about';
const ARTIFACT_PLAY_LISTING = 'play-listing';
const ARTIFACT_PLAY_LISTING_MANIFEST = 'play-listing-manifest';
const ARTIFACT_PACKAGE_NAME = 'package_name';
const ARTIFACT_PUBLISH_PROPERTIES = 'publish_properties';
const ARTIFACT_CLOUD_WATCH = 'cloudWatch';
const ARTIFACT_CONSOLE_TEXT = 'consoleText';
const ARTIFACT_WHATS_NEW = 'whats_new';
const ARTIFACT_HTML = 'html';
const ARTIFACT_PWA = 'pwa';
const ARTIFACT_ENCRYPTED_KEY = 'encrypted_key';
const ARTIFACT_ASSET_PACKAGE = 'asset-package';
const ARTIFACT_ASSET_PREVIEW = 'asset-preview';
const ARTIFACT_ASSET_NOTIFY = 'asset-notify';
const ARTIFACT_DATA_SAFETY_CSV = 'data-safety-csv';

const ARTIFACT_PUBLISH_URL = 'publishUrl';

export function artifacts(
  build: Prisma.buildGetPayload<{
    select: {
      targets: true;
      artifact_url_base: true;
      console_text_url: true;
      artifact_files: true;
    };
  }>
) {
  const { targets, artifact_url_base: base, artifact_files: files } = build;
  // We need to at least have one artifact or the current Portal will fail to parse the JSON.
  // TODO: Treat these like the others once Portal is fixed.
  const artifacts = {
    [ARTIFACT_VERSION]: getArtifactUrl(/version\.json/, base, files),
    [ARTIFACT_CLOUD_WATCH]: build.console_text_url,
    // We used to return consoleText as the first item that matched "\.log" and we REALLY want console.log
    // which is generated by BuildEngine.  There is a APK_NAME-output.log which doesn't have everything in the log.
    [ARTIFACT_CONSOLE_TEXT]: getArtifactUrl(/console\.log/, base, files),
    [ARTIFACT_PUBLISH_PROPERTIES]: getArtifactUrl(/publish-properties\.json/, base, files)
  } as Record<string, string | undefined>;
  if (targets?.match('apk')) {
    artifacts[ARTIFACT_AAB] = getArtifactUrl(/\.aab/, base, files);
    const count = getArtfactFilenameCount(/\.apk/, files);
    if (count > 1) {
      for (const apk of getArtifactUrls(/\.apk/, base, files) ?? []) {
        const matches = apk.match(/-([^.]+)\.apk/);
        artifacts[matches?.at(1) + '-' + ARTIFACT_APK] = apk;
      }
    } else {
      artifacts[ARTIFACT_APK] = getArtifactUrl(/\.apk/, base, files);
    }
    artifacts[ARTIFACT_ENCRYPTED_KEY] = getArtifactUrl(/_key\.pepk/, base, files);
    artifacts[ARTIFACT_ABOUT] = getArtifactUrl(/about\.txt/, base, files);
    artifacts[ARTIFACT_DATA_SAFETY_CSV] = getArtifactUrl(/data_safety\.csv/, base, files);
  }

  if (targets?.match('play-listing')) {
    artifacts[ARTIFACT_PLAY_LISTING] = getArtifactUrl(/play-listing\/index\.html/, base, files);
    artifacts[ARTIFACT_PLAY_LISTING_MANIFEST] = getArtifactUrl(
      /play-listing\/manifest\.json/,
      base,
      files
    );
    artifacts[ARTIFACT_VERSION_CODE] = getArtifactUrl(/version_code\.txt/, base, files);
    artifacts[ARTIFACT_PACKAGE_NAME] = getArtifactUrl(/package_name\.txt/, base, files);
    artifacts[ARTIFACT_PUBLISH_PROPERTIES] = getArtifactUrl(
      /publish-properties\.json/,
      base,
      files
    );
    artifacts[ARTIFACT_WHATS_NEW] = getArtifactUrl(/whats_new\.txt/, base, files);
  }

  if (targets?.match('play-html')) {
    artifacts[ARTIFACT_HTML] = getArtifactUrl(/html\.zip/, base, files);
  }

  if (targets?.match('pwa')) {
    artifacts[ARTIFACT_PWA] = getArtifactUrl(/pwa\.zip/, base, files);
  }

  if (targets?.match('asset-package')) {
    artifacts[ARTIFACT_ASSET_PACKAGE] = getArtifactUrl(/asset-package\/.*\.zip/, base, files);
    artifacts[ARTIFACT_PACKAGE_NAME] = getArtifactUrl(/package_name\.txt/, base, files);
    artifacts[ARTIFACT_ASSET_PREVIEW] = getArtifactUrl(/asset-package\/preview\.html/, base, files);
    artifacts[ARTIFACT_ASSET_NOTIFY] = getArtifactUrl(/asset-package\/notify\.json/, base, files);
  }

  return artifacts;
}

export function releaseArtifacts(
  release: Prisma.releaseGetPayload<{
    select: {
      artifact_url_base: true;
      console_text_url: true;
      artifact_files: true;
    };
  }>
) {
  const { artifact_url_base: base, artifact_files: files } = release;
  return {
    [ARTIFACT_VERSION]: getArtifactUrl(/version\.json/, base, files),
    [ARTIFACT_CLOUD_WATCH]: release.console_text_url,
    [ARTIFACT_PUBLISH_URL]: getArtifactUrl(/console\.log/, base, files)
  } as Record<string, string | undefined>;
}

export function getArtifactUrl(
  pattern: RegExp,
  base: string | null,
  artifact_files: string | null
) {
  const filename = getArtifactFilename(pattern, artifact_files);
  if (filename) {
    return (base ?? '') + encodeFilename(filename);
  }
  return undefined;
}
function encodeFilename(filename: string) {
  return encodeURI(filename);
}
export function getArtifactFilename(pattern: RegExp, artifact_files: string | null) {
  return artifact_files?.split(',').find((f) => f.match(pattern)) ?? null;
}
function getArtfactFilenameCount(pattern: RegExp, artifact_files: string | null) {
  return artifact_files?.split(',').filter((f) => f.match(pattern)).length ?? 0;
}
function getArtifactUrls(
  pattern: RegExp,
  artifact_url_base: string | null,
  artifact_files: string | null
) {
  const urls = artifact_files
    ?.split(',')
    .filter((f) => f.match(pattern))
    .map((f) => (artifact_url_base ?? '') + encodeFilename(f));
  return urls?.length ? urls : null;
}

export type BuildForPrefix = Prisma.buildGetPayload<{
  select: { id: true; job: { select: { id: true; app_id: true } } };
}>;

export type ReleaseForPrefix = Prisma.releaseGetPayload<{
  select: { id: true; build: { select: { job: { select: { id: true; app_id: true } } } } };
}>;

export type ProviderForPrefix = BuildForPrefix | ReleaseForPrefix;

export function getArtifactPath(
  job: Prisma.jobGetPayload<{ select: { app_id: true; id: true } }>,
  productionStage: string,
  isPublish = false
) {
  return `${productionStage}/jobs/${isPublish ? 'publish' : 'build'}_${job.app_id}_${job.id}`;
}

export function getBasePrefixUrl(artifacts_provider: ProviderForPrefix, productStage: string) {
  const artifactPath =
    'build' in artifacts_provider
      ? getArtifactPath(artifacts_provider.build.job, productStage, true)
      : getArtifactPath(artifacts_provider.job, productStage, true);
  return `${artifactPath}/${artifacts_provider.id}`;
}

export type BuildForArtifacts = Prisma.buildGetPayload<{
  select: { id: true; artifact_url_base: true; artifact_files: true; version_code: true };
}>;

export type ReleaseForArtifacts = Prisma.releaseGetPayload<{
  select: { id: true; artifact_url_base: true; artifact_files: true };
}>;

export type ProviderForArtifacts = BuildForArtifacts | ReleaseForArtifacts;

export function beginArtifacts(artifacts_provider: ProviderForArtifacts, baseUrl: string) {
  artifacts_provider.artifact_url_base = baseUrl;
  artifacts_provider.artifact_files = null;
}

export function handleArtifact(provider: ProviderForArtifacts, key: string, contents: string = '') {
  if ('version_code' in provider) {
    const [type, name] = Build.artifactType(key);
    if (type !== Build.Artifact.Unknown) {
      if (provider.artifact_files) {
        provider.artifact_files += ',' + name;
      } else {
        provider.artifact_files = name;
      }

      if (type === Build.Artifact.VersionCode) {
        provider.version_code = Number(contents);
      }
    }
  } else {
    const [type, name] = Release.artifactType(key);
    if (type !== Release.Artifact.Unknown) {
      if (provider.artifact_files) {
        provider.artifact_files += ',' + name;
      } else {
        provider.artifact_files = name;
      }
    }
  }
}
